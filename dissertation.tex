\documentclass{lib/styles/default-style}

\begin{document}
\pagestyle{default-numbered}
\startPageCountFrom{3}

\tableofcontents

\newpage


\unnumberedSection{ВСТУП}

\startSection{АНАЛІЗ ІСНУЮЧИХ ПЛАТФОРМ ДЛЯ СТВОРЕННЯ ДЕЦЕНТРАЛІЗОВАНИХ ДОДАТКІВ}

\subsection{Ethereum}

    Платформа для створення практично будь-яких децентралізованих
    онлайн-сервісів на базі блокчейна (Đapps), що працюють на базі розумнихĐapps), що працюють на базі розумних), що працюють на базі розумних
    контрактів. Реалізована як єдина децентралізована віртуальна машина. Ідея була
    втілена 30 липня 2015 року. Оскільки Ethereum сильно спрощує і здешевлює
    впровадження блокчейна, його впроваджують як великі гравці, такі як Microsoft, IBM, Acronis,
    Сбербанк, банківський консорціум R3, так і нові стартапи.

    У кінці 2013 року Ethereum запропонував дослідник
    і програміст криптовалют Віталік Бутерін. Розвиток фінансувався через інтернет-краудфандінг, який проходив
    у липні-серпні 2014 року. Потім система вийшла у світ 30 липня 2015 року, при цьому 72 мільйони монет були
    створені "попередньо". Це становить близько 68 відсотків загального обсягу постачання у 2019 році.

    У 2016 році,
    внаслідок експлуатації вразливості в програмному забезпеченні проекту, та подальшого розкрадання ефіру на суму 
    50 мільйонів доларів, Ethereum було розділено на дві окремі блокчейн - нова окрема версія стала Ethereum (ETH), а оригінал продовжувався 
    як Ethereum Classic (ETC).

    Ethereum є дуже потужною платформою розробки через технологію розумних контрактів

    Розумний контракт - це код, який працює на EVM.
    Смарт-контракти можуть приймати та зберігати ефір, дані або комбінацію обох.
    Потім, використовуючи логіку, запрограмовану в договорі, він може поширювати
    цей ефір на інші рахунки або навіть інші смарт-контракти.

    Як приклад, приведемо відомий контракт з Бобом та Алісою (рисунок \ref{img:alice-bob-contract-example}). Аліса хоче найняти Боба, щоб побудувати їй внутрішній дворик,
    і вони використовують контракт для депонування (місце для зберігання грошей, доки умова не буде виконана),
    щоб зберігати свій ефір до остаточної транзакції.

    \printImage[1][0.3]{alice-bob-contract-example}{Приклад виконання контракта Боба та Аліси}

    Розумні контракти пишуться мовою, що називається "Solidity". Solidity має статичний тип і підтримує механізм успадкування,
    бібліотеки та складні,визначені користувачем типи. Синтаксис Solidity схожий на JavaScript.

    Програми, що використовують смарт-контракти для їх обробки, називаються "децентралізованими програмами" або "dapps".
    Користувацькі інтерфейси для цих daaps складаються з відомих мов, таких як HTML, CSS та JavaScript.
    Саму програму можна розмістити на традиційному веб-сервері або на децентралізованій файловій службі, наприклад, Swarm або IPFS.

    Враховуючи переваги блокчейна Ethereum, dapp може бути рішенням для багатьох галузей, включаючи, але не обмежуючись ними:

    \listDefault{
        \item Бухгалтерський облік;
        \item Фінанси;
        \item Логістика;
        \item Нерухомість;
        \item Електронні магазиги (маркетплейси).
    }

\subsection{Hyperledger}

    Комплексний проект розробки блокчейну з відкритим вихідним кодом та пов'язаних з цим інструментів,
    який було розпочато Linux Foundation у грудні 2015 року. Основною метою проекту є підтримка спільної
    розробки мереж з розподіленим реєстром, заснованих на технології блокчейн.
    
    У грудні 2015 року Linux Foundation анонсувала створення проекту Hyperledger.
    Імена компаній-засновників були оголошені у лютому 2016, до яких 29 березня того ж року приєдналися ще
    десять учасників і було затверджено склад ради правління. 29 травня виконавчим директором проекту призначили Брайана Белендорфа.
    
    Метою проекту є посилення міжгалузевої співпраці за допомогою технології блокчейну та мереж з розподіленим реєстром.
    Особлива увага приділяється підвищенню продуктивності та надійності цих систем (у порівнянні з аналогічними криптовалютними розробками),
    аби вони могли використовуватися технологічними, фінансовими та компаніями-постачальниками в масштабах глобальних комерційних оборудок. 
    Проект поєднуватиме незалежні відкриті стандарти та протоколи за допомогою фреймворків для створення специфічних модулей, включно з 
    блокчейнами з власними механізмами досягнення консенсусу та порядком збереження даних, а також ідентифікаційними сервісами, контролем
    доступу та смарт-контрактами. 	Попри чутки, згідно з заявою Брайана Белендорфа, введення та використання власної криптовалюти у проекті
    ніколи не відбудеться.    На початку 2016 проект розпочав розглядати пропозиції щодо створення вихідного коду
    та інших ключових технологічних елементів. Однією з перших пропозицій було поєднати попередні розробки Digital Asset,
    механізм досягнення консенсусу від Blockstream та OpenBlockchain від IBM. Пізніше ця технологія отримала назву Fabric (рисунок \ref{img:hyperledger-struct}).
    
    \printImage[1][0.7]{hyperledger-struct}{Структурна схема платформи Hyperledger Fabric}

    У травні розпочалася розробка мережі з розподіленим реєстром Sawtooth від Intel. 

    12 червня 2017 року проект анонсував готову до промислового використання версію Hyperledger Fabric 1.0 який одразу 
    почав набирати популярність на ринку ICO. Того ж місяця London Stock Exchange Group, спільно з IBM, заявила про початок
    розробки блокчейн-платформи на базі Hyperledger Fabric для випуску цифрових акцій італійських компаній. 
    
    У серпні 2017, компанія Oracle приєдналася до консорціуму Hyperledger і  оголосила про початок розробки власного хмарного блокчейн-сервісу. 
    
    У вересні 2017 Королівський банк Канади почав використовувати Hyperledger для міжбанківських розрахунків з США. 
   
    Hyperledger забезпечує такі функціональні можливості для мережі:
    
    \listDefault{
        \item Управління ідентичністю - Hyperledger Fabric надає послугу посвідчення членства,
        яка керує ідентифікаторами користувачів та аутентифікує всіх учасників мережі.
        Списки контролю доступу можуть використовуватися для надання додаткових рівнів дозволу через авторизацію конкретних мережевих операцій;
        \item Приватність та конфідейційність - Hyperledger дозволяє конкуруючим інтересам бізнесу
        та будь-яким групам, які потребують приватних, конфіденційних транзакцій, співіснувати в одній і тій же дозволеній мережі.
        Приватні канали - це обмежені шляхи обміну повідомленнями, які можна використовувати для
        забезпечення конфіденційності та конфіденційності транзакцій для конкретних підмножин членів мережі.
        Усі дані, включаючи інформацію про трансакції, учасників та каналів, на каналі є невидимими та недоступними
        для будь-яких членів мережі, яким явно не надано доступ до цього каналу;
        \item Ефективна обробка - Hyperledger Fabric призначає мережеві ролі за типом вузла.
        Для забезпечення одночасності та паралелізму в мережі виконання транзакцій відокремлено
        від впорядкування та зобов'язань транзакцій. Виконання транзакцій перед їх
        замовленням дозволяє кожному вузлу однорангових обробляти одночасно кілька транзакцій.
        Це одночасне виконання збільшує ефективність обробки кожного партнера та прискорює доставку транзакцій до служби замовлення;
        \item Chaincode - це визначення програмного забезпечення як активів та інструкція щодо
        транзакцій для зміни активів. Chaincode виконує правила читання або зміни пар ключових
        значень або іншої інформації бази даних стану. Функції Chaincode виконуються в базі даних поточного стану
        і ініціюються через пропозицію транзакцій.
    }
\subsection{Corda}

    Платформа з відкритим вихідним кодом, яка дозволяє підприємствам здійснювати операції безпосередньо
    та у суворій конфіденційності за допомогою інтелектуальних контрактів, зменшуючи витрати на операції
    та ведення записів та оптимізацію бізнес-операції. У світі блокчейн платформ, де всі дані передаються
    всім учасникам, сувора модель конфіденційності Corda дозволяє бізнесу здійснювати операції без проблем.
    R3 поставляє два повністю сумісні дистрибутиви платформи - Corda, безкоштовне завантаження коду,
    доступного на GitHub та Corda Enterprise, комерційній версії, яка пропонує функції та послуги, які налаштовані для сучасних підприємств.

    Основоположним об'єктом в концепції є "державний" об'єкт, який є цифровим документом,
    який реєструє існування, зміст та поточний стан угоди між двома або більше сторонами.
    Він призначений для обміну лише з тими, хто має законну причину бачити це.
    Для забезпечення узгодженості глобальної спільної системи, де не всі дані видно всім учасникам,
    використовують безпечні криптографічні хеші для ідентифікації сторін і даних, а також для зв’язку користувачів з попередніми перетвореннями,
    щоб забезпечити ланцюги походження. Головну базу даних визначають як сукупність незмінних об'єктів стану.

    На рисунку \ref{img:corda-example} зображений приклад, державний об'єкт,
    який представляє депозит у розмірі 100 фунтів стерлінгів у комерційному банку,
    що належить вигаданій судноплавній компанії.
    Державний об'єкт посилається на код договору,
    який регулює його переходи, який, ймовірно,
    буде написаний один раз і повторно використаний величезною кількістю штатів, і може посилатися на хеш тої, що регулює юридичну прозу.

    \printImage[1][0.7]{corda-example}{Схема роботи децентралізованого банку на платформі Corda}

    На відміну від більшості існуючих сьогодні платформ для створення блокчейнів додатків, Corda була побудована з чіткою метою
    запису та забезпечення ділових угод між торговими партнерами.
    Як такий, платформа використовує унікальний підхід до розподілу даних та семантики транзакцій,
    підкреслюючи особливості розподілених баз даних, привабливих для фірм, а саме надійне виконання контрактів в автоматизованому
    та примусовому виконанні.

\subsection{Quorum}

    Quorum - протокол розподіленої бази даних на основі Ethereum, розроблений для забезпечення таких галузей,
    як фінанси, ланцюжок поставок, роздрібна торгівля, нерухомість, тощо з дозволеною реалізацією Ethereum,
    що підтримує конфіденційність транзакцій та контрактів.

    Quorum включає мінімалістичний форк клієнта Go Ethereum (geth) і,
    як такий, використовує роботу, яку розпочала спільнота розробників Ethereum.

    Основними відмінностями Quorum є:

    \listDefault{
        \item Конфіденційність транзакцій та контрактів;
        \item Кілька механізмів консенсусу на основі голосування;
        \item  Мережеве/однорангове управління дозволами;
        \item Більш висока продуктивність;
    }

    На даний момент, Quorum складається з архітектурних компонентів, зображених на рисунку \ref{img:quorum-architecture}

    \printImage[1][0.4]{quorum-architecture}{Схема логічної архітектури Quorum}


\subsection{Висновок}

% TODO: Make conclusion for technologies

\startSection{КОНЦЕПЦІЯ ТА ТЕХНОЛОГІЧНІ ПАРАДИГМИ ПЛАТФОРМИ}

%TODO Blabla about conceptions

\subsection{Програмна віртуальна машина}

    Програмна віртуальна машина (PVM), іноді називається віртуальною машиною програми
    або керованим середовищем виконання (MRE), 
    працює як звичайна програма всередині операційної системи та підтримує єдиний процес.
    Вона створюється при запуску цього процесу і руйнується, коли він закінчується.
    Її мета полягає в тому, щоб створити незалежне від платформи середовище програмування,
    яке відкидує деталі апаратного обладнання або операційної системи і
    дозволяє програмі виконуватися однаково на будь-якій платформі.

    Процес VM забезпечує абстракцію високого рівня
    - мову програмування високого рівня (порівняно з низькорівневою абстракцією ISA системи VM).
    Програмна віртуальна машина реалізуються за допомогою інтерпретатора;
    ефективність, порівнянна зі скомпільованими мовами програмування, може бути досягнута за допомогою компіляції "just in time".


    Цей тип VM набув популярності в мові програмування Java (рисунок \ref{img:hotspot-jvm}), яка реалізована за допомогою віртуальної машини Java.
    Інші приклади включають віртуальну машину Parrot і .NET Framework, яка працює на VM під назвою " Common Language Runtime".
    Усі вони можуть служити шаром абстракції для будь-якої мови комп'ютера.
    
    \printImage[1][0.7]{hotspot-jvm}{Архітектура Hotspot JVM}
    
    Особливим випадком віртуальних машин управління є системи,
    які абстрагуються над механізмами зв'язку (потенційно гетерогенного) комп'ютерного кластеру.
    Такий тип VM складається не з одного програмного процесу, а з одного процесу на фізичній машині в кластері.
    Вони розроблені для полегшення завдання програмування багатопоточних додатків, дозволяючи програмісту зосередитися на алгоритмах,
    а не на механізмах зв'язку, що забезпечуються взаємозв'язком та ОС.
    Вони не приховують факту, що спілкування відбувається, і не намагаються представити кластер як єдину машину.

    На відміну від інших віртуальних машин, ці системи не забезпечують конкретної мови програмування,
    але вбудовані в існуючу мову;
    зазвичай така система забезпечує прив'язку для декількох мов (наприклад, C та Fortran).
    Прикладами є паралельна віртуальна машина (PVM)
    та інтерфейс передачі повідомлень (MPI).
    
    Вони не є строго віртуальними машинами, оскільки додатки, що працюють на них, все ще мають
    доступ до всіх служб ОС і тому не обмежені системою.

    Тож, із зазначених переваг можна виділити:

    \listDefault{
        \item Швидкий час розробки - написання програми не займе багато часу,
        оскільки розробникам не потрібно кодувати функції для окремих платформ та специфікацій;
        \item Безпечний код - керовані режими виконання просувають безпечніший код,
        знімаючи з розробників частину відповідальності за безпеку та управління обладнанням;
        \item Нижчі витрати на розгортання - компонентна архітектура спрощує та швидше розгортає додатки у корпоративному середовищі,
        що характеризується багатьма платформами, пристроями та застарілими системами;
        \item Більш якісне програмне забезпечення - керований час виконання звільняє розробників зосереджуватися
        на бізнес-логіці та коді, специфічних для програми, зменшуючи при цьому кількість помилок кодування;
        \item Агностична платформа - завдяки виконанню часу перекладу між вашим додатком та операційною системою
        ви можете кодувати один раз, дозволяючи клієнтам запускати програму в декількох системах;
        \item Чистота коду - простота функціоналу дозволяє писати модульний код, який можна переробити в нові програми та нові системи.
    }

    Отже, із вище зазначених переваг можна точно сказати, шо віртуальна машина необхідна для реалізації платформи, так як це допоможе
    в реалізації кросплатформеності та створить безпечну середу для виконання криптографічних операції.


\subsection{Протокол серіалізації даних}

    Серіалізація даних - це процес перетворення об'єктів даних (рисунок \ref{img:serealization-example}), що знаходяться у складних структурах даних,
    у потік байтів для цілей зберігання, передачі та розповсюдження на фізичних пристроях.

    Комп'ютерні системи можуть відрізнятися за своєю апаратною архітектурою, ОС,
    механізмами адресації. Внутрішні бінарні представлення даних також відповідно
    змінюються в кожному середовищі. Зберігання та обмін даними між такими різними середовищами
    вимагає нейтрального для платформи та мови формату даних, який розуміють усі системи.

    Після передачі серіалізованих даних з вихідної машини на машину призначення
    здійснюється зворотний процес створення об'єктів із послідовності байтів, що називається десяріалізацією.
    Реконструйовані об'єкти - це клони вихідного об'єкта.

    Вибір формату серіалізації даних для програми залежить
    від таких факторів, як складність даних, потреба в читабельності людини, швидкість
    та обмеження місця для зберігання. XML, JSON, BSON, YAML, MessagePack і protobuf - деякі
    часто використовувані формати серіалізації даних.

    \printImage[1][0.7]{serealization-example}{Узагальнений алгоритм серіалізації}

    Комп'ютерні дані зазвичай організовані в структурах даних, таких як масиви,
    таблиці, дерева, класи. Коли структури даних потрібно зберігати або передавати
    в інше місце, наприклад, через мережу, вони серіалізуються.

    Для простих лінійних даних (число або рядок) нічого робити.
    Серіалізація стає складною для вкладених структур даних та посилань на об'єкти.
    Коли об'єкти вкладені в кілька рівнів, наприклад, у деревах, він згортається на ряд
    байтів, і достатньо інформації (наприклад, порядок обходу) включається для відновлення
    початкової структури дерева на стороні призначення.

    Коли об'єкти із посиланнями вказівників
    на інші змінні члена серіалізовані, посилаються об'єкти відстежуються та
    серіалізуються, забезпечуючи, щоб той самий об’єкт не був серіалізований більше одного разу.
    Однак усі вкладені об'єкти теж повинні бути серіалізованими.

    Нарешті, серіалізований потік даних зберігається у послідовності байтів,
    використовуючи стандартний формат.
    ISO-8859-1 - популярний формат для 1-байтного представлення англійських символів та цифр.
    UTF-8 - світовий стандарт кодування багатомовних, математичних та наукових даних; кожен символ може приймати 1-4 байти даних у Unicode.

    На рисунку \ref{img:serialization-data-example} зображено приклад серіалізації структури у текстовий формат.

    \printImage[1][0.6]{serialization-data-example}{Приклад серіалізації даних}
    
    Якщо визначати, які з форматів для яких цілей підходять краще, то можна визначити, що:

    \listDefault{
        \item Швидкість - бінарні формати швидші (рисунок \ref{img:protobuf-example}), ніж текстові формати.
        Google Protobuf має найкращі показники на сьогодні.
        При стиснених даних різниця швидкостей ще більше.
        Для додатків, які не потребують інтенсивного використання даних або в режимі реального часу,
        JSON є кращим із-за читабельності та відсутності схем;
        \item Розмір даних - це стосується фізичного простору в байтах після серіалізації.
        Для невеликих даних стислі дані JSON займають більше місця в порівнянні з бінарними форматами, як Protobuf.
        При великих файлах розрив звужується. Як правило, бінарні формати завжди займають менше місця;
        \item Корисність - людиночитаємі формати, такі як JSON, природно переважніші перед бінарними форматами.
        Для редагування даних добре підходить YAML.
        Для складних типів даних бібліотеки міжплатформової серіалізації дозволяють визначати структуру даних на схемах
        (для текстових форматів) або IDL (для бінарних форматів).
        Визначення схеми в Protobuf дуже легко, якщо використовувати вбудовані інструменти;
        \item Сумісність, розширюваність - JSON є закритим форматом.
        XML є середнім за версією схеми. Зворотна сумісність (розширювані схеми) найкраще обробляється Protobuf.
    }

    \printImage[1][0.6]{protobuf-example}{Графік, на якому Uber Engineering показує, що Protobuf/Thift із стисненням zlib/Snappy
    пропонує найкращий компроміс між швидкістю та розміром.}

    Навіть у Big Data серіалізація стосується перетворення даних у портативні потоки байтів.
    Але управління схемою - ще одна важлива ціль у Big Data.
    Проблеми з узгодженістю даних, такі як пробіли або неправильні значення даних,
    можуть бути дуже дорогими, залучаючи великі зусилля щодо очищення даних.

    Наступний важливий аспект - можливість легко розділяти
    та реконструювати дані (наприклад, MapReduce).
    JSON або XML можуть не працювати належним чином.
    Apache Hadoop має власний формат серіалізації на основі схеми під назвою Avro (рисунок \ref{img:avro}),
    схожий на Protobuf. Схеми Apache також визначаються на основі JSON.
    Apache Hadoop використовує RPC для розмови з різними компонентами. 

    \printImage[1][0.6]{avro}{Принцип роботи Avro}
    
    Механізм серіалізації є важливою частиною платформи, оскільки не тільки дозволяє досягти агностичності, але і збільшити
    швидкодію та зменшити об’єм сховища даних.

\subsection{Протокол консенсусу}

    Принциповою проблемою розподілених обчислювальних і багатоагентних систем
    є досягнення загальної надійності системи за наявності низки несправних процесів.
    Це часто вимагає від процесів узгодження певної вартості даних, яка потрібна під час обчислення.
    Приклади застосувань консенсусу включають, чи слід здійснювати транзакцію в базі даних, узгоджуючи особу лідера,
    центральну машинну реплікацію (генезис) та атомарну трансляцію.
    
    Однак у процесі застосування технології blockchain виникає багато проблем і питань,
    серед яких велике питання - як розробити відповідний протокол консенсусу.

    Консенсус блокчейна полягає в тому, що всі вузли підтримують однакове розподілене сховище.
    У традиційній архітектурі програмного забезпечення консенсус навряд чи є проблемою через існування центрального сервера,
    отже, інші вузли потрібно лише узгодити з сервером. Однак у розподіленій мережі, такій як блокчейн, кожен вузол є і хостом,
    і сервером, і йому потрібно обмінюватися інформацією з іншими вузлами, щоб досягти консенсусу. Іноді деякі вузли будуть
    працювати в режимі онлайн або в режимі офлайн, а також з’являться деякі шкідливі вузли, що серйозно вплине на систему або знищить
    процес консенсусу. Тому відмінний консенсус-протокол може допустити виникнення цих явищ і мінімізувати шкоду,
    щоб не вплинути на кінцевий результат консенсусу.
    
    Крім того, прийнятий системою протокол консенсусу
    також повинен бути придатним для типу блокчейн, який використовується системою. Загалом, можна виділити три основні типи blockchain:
    загальний блокчейн, консорціумний блокчейн та приватний блокчейн.
    
    Кожен тип blockchain має різні сценарії застосування.
    Таким чином, прийнятий протокол консенсусу повинен відповідати вимогам конкретного сценарію застосування.

    \subsubsection{POW}

    PoW вибирає один вузол, щоб створити новий блок у кожному раунді консенсусу шляхом конкуренції з
    обчислювальної потужності. У змаганні вузлам-учасникам потрібно розв'язати криптографічну проблему.
    Вузол, який першим вирішить задачі, може мати право створити новий блок.
    Потік створення блоку в PoW представлений на рисунтку \ref{img:flow-pow}.
    Розв'язати проблему, яку представляє PoW дуже важко.
    Вузлам потрібно постійно коригувати значення nonce, щоб отримати правильну відповідь,
    що вимагає великої обчислювальної потужності.
    Зловмисник може скинути один блок в ланцюжку, але в міру збільшення дійсних блоків ланцюга
    також накопичується навантаження, тому для скидання довгого ланцюга потрібна величезна обчислювальна потужність.
    PoW належить до протоколів консенсусу ймовірнісно-кінцевих, оскільки він гарантує можливу послідовність.

    \printSubImage[1][0.6]{flow-pow}{Cхема POW алгоритму}

    \subsubsection{POS}

    У PoS вибір кожного раунду вузла, який створює новий блок, залежить від утримуваного кола, а не обчислювальної потужності.
    Хоча вузлам все-таки потрібно вирішити задачу із SHA256:



    Від PoW відмінність полягає в тому, що вузлам не потрібно багато разів коригувати нуль,
    натомість ключовим для вирішення цієї задачі є кількість ставок (монет).
    Отже, PoS - це енергозберігаючий консенсус-протокол, який використовує спосіб стимулювання внутрішньої валюти,
    а не витрачає багато обчислювальної сили для досягнення консенсусу.
    Схема алгоритму виконання PoS показана на рисунку \ref{img:flow-pos}.

    Як і PoW, PoS також є протоколом консенсусу ймовірнісно-кінцевих.
    PPcoin була першою криптовалютою, яка застосувала PoS до блокчейн.
    У PPcoin, крім розміру ставки, вік монети також вводиться для вирішення задачі PoS.
    Наприклад, якщо ви тримаєте 10 монет протягом 20 днів, то ваш вік монет - 200.
    Після того, як вузол створить новий блок, його вік монет очиститься до 0.
    Крім PPcoin, багато криптовалют використовують PoS, наприклад , Nxt, Ouroboros.
      
    \printSubImage[1][0.6]{flow-pos}{Cхема POS алгоритму}

    \subsubsection{DPoS}

\subsection{Механізм обробки подій}
\subsection{Механізм зовнішнього доступу}


\startSection{ПРОЕКТУВАННЯ КОМПОНЕНТІВ ПЛАТФОРМИ}



\startSection{РЕАЛІЗАЦІЯ ТА ТЕХНІЧНА ОПТИМІЗАЦІЯ}



\startSection{РОЗРОБЛЕННЯ СТАРТАП-ПРОЕКТУ}
\startSection{ВИСНОВКИ}
\startSection{СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ}

\end{document}